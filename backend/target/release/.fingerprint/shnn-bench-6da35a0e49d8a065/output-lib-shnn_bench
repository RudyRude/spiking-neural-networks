{"$message_type":"diagnostic","message":"unused import: `std::time::Instant`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":232,"byte_end":250,"line_start":6,"line_end":6,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"use std::time::Instant;","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":228,"byte_end":252,"line_start":6,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::time::Instant;","highlight_start":1,"highlight_end":24},{"text":"use crate::{BenchmarkResult, BenchmarkRunner, ComparisonResult};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::time::Instant`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::time::Instant;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `FloatMath`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":430,"byte_end":439,"line_start":11,"line_end":11,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx, sqrt_approx},","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":430,"byte_end":441,"line_start":11,"line_end":11,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx, sqrt_approx},","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `FloatMath`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:11:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     math::{FloatMath, exp_approx, ln_approx, sqrt_appr\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `GlobalAlloc` and `Layout`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":249,"byte_end":260,"line_start":7,"line_end":7,"column_start":18,"column_end":29,"is_primary":true,"text":[{"text":"use std::alloc::{GlobalAlloc, Layout};","highlight_start":18,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":262,"byte_end":268,"line_start":7,"line_end":7,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"use std::alloc::{GlobalAlloc, Layout};","highlight_start":31,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":232,"byte_end":271,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::alloc::{GlobalAlloc, Layout};","highlight_start":1,"highlight_end":39},{"text":"use std::sync::atomic::{AtomicUsize, Ordering};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `GlobalAlloc` and `Layout`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:7:18\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::alloc::{GlobalAlloc, Layout};\n  \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AtomicUsize` and `Ordering`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":295,"byte_end":306,"line_start":8,"line_end":8,"column_start":25,"column_end":36,"is_primary":true,"text":[{"text":"use std::sync::atomic::{AtomicUsize, Ordering};","highlight_start":25,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":308,"byte_end":316,"line_start":8,"line_end":8,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"use std::sync::atomic::{AtomicUsize, Ordering};","highlight_start":38,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":271,"byte_end":319,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::atomic::{AtomicUsize, Ordering};","highlight_start":1,"highlight_end":48},{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `AtomicUsize` and `Ordering`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:8:25\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::sync::atomic::{AtomicUsize, Ordering};\n  \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::sync::Arc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":323,"byte_end":337,"line_start":9,"line_end":9,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":319,"byte_end":339,"line_start":9,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":20},{"text":"use crate::{BenchmarkResult, BenchmarkRunner, MemoryTracker};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::sync::Arc`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:9:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::sync::Arc;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `shnn_async_runtime::SHNNRuntime`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":453,"byte_end":484,"line_start":13,"line_end":13,"column_start":5,"column_end":36,"is_primary":true,"text":[{"text":"use shnn_async_runtime::SHNNRuntime;","highlight_start":5,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":449,"byte_end":486,"line_start":13,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use shnn_async_runtime::SHNNRuntime;","highlight_start":1,"highlight_end":37},{"text":"use shnn_lockfree::{MPMCQueue, LockFreeStack};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `shnn_async_runtime::SHNNRuntime`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:13:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use shnn_async_runtime::SHNNRuntime;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `Deserialize` and `Serialize`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":554,"byte_end":563,"line_start":15,"line_end":15,"column_start":22,"column_end":31,"is_primary":true,"text":[{"text":"use shnn_serialize::{Serialize, Deserialize};","highlight_start":22,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":565,"byte_end":576,"line_start":15,"line_end":15,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"use shnn_serialize::{Serialize, Deserialize};","highlight_start":33,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":533,"byte_end":579,"line_start":15,"line_end":16,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use shnn_serialize::{Serialize, Deserialize};","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `Deserialize` and `Serialize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:15:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use shnn_serialize::{Serialize, Deserialize};\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `ComparisonResult`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":356,"byte_end":372,"line_start":9,"line_end":9,"column_start":47,"column_end":63,"is_primary":true,"text":[{"text":"use crate::{BenchmarkResult, BenchmarkRunner, ComparisonResult};","highlight_start":47,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":354,"byte_end":372,"line_start":9,"line_end":9,"column_start":45,"column_end":63,"is_primary":true,"text":[{"text":"use crate::{BenchmarkResult, BenchmarkRunner, ComparisonResult};","highlight_start":45,"highlight_end":63}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ComparisonResult`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:9:47\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m BenchmarkRunner, ComparisonResult};\n  \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `FloatMath`, `Vector`, `leaky_relu`, `ln_approx`, `relu`, and `tanh`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":397,"byte_end":403,"line_start":12,"line_end":12,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    Vector, Matrix, SparseMatrix,","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":444,"byte_end":448,"line_start":13,"line_end":13,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":18,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":450,"byte_end":454,"line_start":13,"line_end":13,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":24,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":456,"byte_end":466,"line_start":13,"line_end":13,"column_start":30,"column_end":40,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":30,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":489,"byte_end":498,"line_start":14,"line_end":14,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":512,"byte_end":521,"line_start":14,"line_end":14,"column_start":35,"column_end":44,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":397,"byte_end":405,"line_start":12,"line_end":12,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    Vector, Matrix, SparseMatrix,","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":444,"byte_end":468,"line_start":13,"line_end":13,"column_start":18,"column_end":42,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":18,"highlight_end":42}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":443,"byte_end":444,"line_start":13,"line_end":13,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":475,"byte_end":476,"line_start":13,"line_end":13,"column_start":49,"column_end":50,"is_primary":true,"text":[{"text":"    activation::{tanh, relu, leaky_relu, sigmoid},","highlight_start":49,"highlight_end":50}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":489,"byte_end":500,"line_start":14,"line_end":14,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":510,"byte_end":521,"line_start":14,"line_end":14,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":33,"highlight_end":44}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":488,"byte_end":489,"line_start":14,"line_end":14,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":521,"byte_end":522,"line_start":14,"line_end":14,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"    math::{FloatMath, exp_approx, ln_approx},","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `FloatMath`, `Vector`, `leaky_relu`, `ln_approx`, `relu`, and `tanh`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:12:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Vector, Matrix, SparseMatrix,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     activation::{tanh, relu, leaky_relu, sigmoid},\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     math::{FloatMath, exp_approx, ln_approx},\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m              \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `TaskPriority` and `Task`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":552,"byte_end":556,"line_start":16,"line_end":16,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"use shnn_async_runtime::{Task, TaskPriority, SHNNRuntime};","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":558,"byte_end":570,"line_start":16,"line_end":16,"column_start":32,"column_end":44,"is_primary":true,"text":[{"text":"use shnn_async_runtime::{Task, TaskPriority, SHNNRuntime};","highlight_start":32,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":552,"byte_end":572,"line_start":16,"line_end":16,"column_start":26,"column_end":46,"is_primary":true,"text":[{"text":"use shnn_async_runtime::{Task, TaskPriority, SHNNRuntime};","highlight_start":26,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":551,"byte_end":552,"line_start":16,"line_end":16,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"use shnn_async_runtime::{Task, TaskPriority, SHNNRuntime};","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":583,"byte_end":584,"line_start":16,"line_end":16,"column_start":57,"column_end":58,"is_primary":true,"text":[{"text":"use shnn_async_runtime::{Task, TaskPriority, SHNNRuntime};","highlight_start":57,"highlight_end":58}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `TaskPriority` and `Task`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:16:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use shnn_async_runtime::{Task, TaskPriority, SHNNRunti\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[33m^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `filled` found for struct `shnn_math::Vector` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":3220,"byte_end":3226,"line_start":104,"line_end":104,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        let v2 = Vector::filled(self.config.vector_size, 2.0);","highlight_start":26,"highlight_end":32}],"label":"function or associated item not found in `shnn_math::Vector`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `shnn_math::Vector` consider using one of the following associated functions:\nshnn_math::Vector::zeros\nshnn_math::Vector::ones\nshnn_math::Vector::from_vec\nshnn_math::Vector::from_slice","code":null,"level":"note","spans":[{"file_name":"crates/shnn-math/src/vector.rs","byte_start":751,"byte_end":786,"line_start":28,"line_end":28,"column_start":5,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn zeros(length: usize) -> Self {","highlight_start":5,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":933,"byte_end":967,"line_start":35,"line_end":35,"column_start":5,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn ones(length: usize) -> Self {","highlight_start":5,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":1079,"byte_end":1120,"line_start":42,"line_end":42,"column_start":5,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn from_vec(data: Vec<Float>) -> Self {","highlight_start":5,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":1193,"byte_end":1234,"line_start":47,"line_end":47,"column_start":5,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn from_slice(data: &[Float]) -> Self {","highlight_start":5,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `fill` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"crates/shnn-math/src/vector.rs","byte_start":6141,"byte_end":6177,"line_start":230,"line_end":230,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn fill(&mut self, value: Float) {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `filled` found for struct `shnn_math::Vector` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:104:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m104\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mlet v2 = Vector::filled(self.config.vector_size, 2\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `shnn_math::Vector`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `shnn_math::Vector` consider using one of the following associated functions:\n      shnn_math::Vector::zeros\n      shnn_math::Vector::ones\n      shnn_math::Vector::from_vec\n      shnn_math::Vector::from_slice\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/vector.rs:28:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn zeros(length: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ones(length: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_vec(data: Vec<Float>) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_slice(data: &[Float]) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `fill` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/vector.rs:230:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn fill(&mut self, value: Float) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `filled` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":4726,"byte_end":4732,"line_start":152,"line_end":152,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        let m2 = Matrix::filled(cols, rows, 2.0);","highlight_start":26,"highlight_end":32}],"label":"function or associated item not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Matrix` consider using one of the following associated functions:\nMatrix::zeros\nMatrix::ones\nMatrix::identity\nMatrix::from_vec\nMatrix::from_nested_vec","code":null,"level":"note","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":789,"byte_end":835,"line_start":30,"line_end":30,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn zeros(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1027,"byte_end":1072,"line_start":39,"line_end":39,"column_start":5,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn ones(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1227,"byte_end":1263,"line_start":48,"line_end":48,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn identity(size: usize) -> Self {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1474,"byte_end":1549,"line_start":57,"line_end":57,"column_start":5,"column_end":80,"is_primary":true,"text":[{"text":"    pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {","highlight_start":5,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1837,"byte_end":1898,"line_start":68,"line_end":68,"column_start":5,"column_end":66,"is_primary":true,"text":[{"text":"    pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {","highlight_start":5,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `fill` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":7605,"byte_end":7641,"line_start":271,"line_end":271,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn fill(&mut self, value: Float) {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `filled` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:152:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let m2 = Matrix::filled(cols, rows, 2.0);\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Matrix`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Matrix` consider using one of the following associated functions:\n      Matrix::zeros\n      Matrix::ones\n      Matrix::identity\n      Matrix::from_vec\n      Matrix::from_nested_vec\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:30:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn zeros(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ones(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn identity(size: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `fill` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:271:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m271\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn fill(&mut self, value: Float) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `mul_matrix` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":4912,"byte_end":4922,"line_start":156,"line_end":156,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                let _result = m1.mul_matrix(&m2).unwrap();","highlight_start":34,"highlight_end":44}],"label":"method not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `mul_matrix` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:156:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m= m1.mul_matrix(&m2).unwrap();\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `Matrix`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `mul_vec` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":5227,"byte_end":5234,"line_start":166,"line_end":166,"column_start":34,"column_end":41,"is_primary":true,"text":[{"text":"                let _result = m1.mul_vec(&v).unwrap();","highlight_start":34,"highlight_end":41}],"label":"method not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `mul_vec` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:166:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let _result = m1.mul_vec(&v).unwrap();\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `Matrix`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `mul_vec` found for struct `SparseMatrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/math.rs","byte_start":13099,"byte_end":13106,"line_start":404,"line_end":404,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"                if let Ok(_result) = sparse_matrix.mul_vec(&vector) {","highlight_start":52,"highlight_end":59}],"label":"method not found in `SparseMatrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `mul_vec` found for struct `SparseMatrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/math.rs:404:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m404\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mrix.mul_vec(&vector) {\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `SparseMatrix`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":4435,"byte_end":4736,"line_start":137,"line_end":144,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // CPU-bound computation","highlight_start":1,"highlight_end":45},{"text":"                    let mut sum = 0u64;","highlight_start":1,"highlight_end":40},{"text":"                    for j in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        sum += (i + j) as u64;","highlight_start":1,"highlight_end":47},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    // Return () since spawn_task expects ()","highlight_start":1,"highlight_end":61},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":4425,"byte_end":4435,"line_start":137,"line_end":137,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":4435,"byte_end":4736,"line_start":137,"line_end":144,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // CPU-bound computation","highlight_start":1,"highlight_end":45},{"text":"                    let mut sum = 0u64;","highlight_start":1,"highlight_end":40},{"text":"                    for j in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        sum += (i + j) as u64;","highlight_start":1,"highlight_end":47},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    // Return () since spawn_task expects ()","highlight_start":1,"highlight_end":61},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    // CPU-bound computation\n                    let mut sum = 0u64;\n                    for j in 0..operations_per_task {\n                        sum += (i + j) as u64;\n                    }\n                    // Return () since spawn_task expects ()\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:137:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m138\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // CPU-bound computation\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut sum = 0u64;\n\u001b[1m\u001b[94m140\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for j in 0..operations_per_task {\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Return () since spawn_task expects ()\n\u001b[1m\u001b[94m144\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":5585,"byte_end":5764,"line_start":164,"line_end":168,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    for _ in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        counter_clone.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":5575,"byte_end":5585,"line_start":164,"line_end":164,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":5585,"byte_end":5764,"line_start":164,"line_end":168,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    for _ in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        counter_clone.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    for _ in 0..operations_per_task {\n                        counter_clone.fetch_add(1, Ordering::Relaxed);\n                    }\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:164:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for _ in 0..operations_per_task {\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         counter_clone.fetch_add(1, \u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     }\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     }\n\u001b[1m\u001b[94m168\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":14400,"byte_end":15412,"line_start":398,"line_end":419,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Simulate spike processing","highlight_start":1,"highlight_end":49},{"text":"                    let mut membrane_potential = 0.0f32;","highlight_start":1,"highlight_end":57},{"text":"                    let threshold = 1.0f32;","highlight_start":1,"highlight_end":44},{"text":"                    let decay = 0.95f32;","highlight_start":1,"highlight_end":41},{"text":"                    let mut spikes_generated = 0u64;","highlight_start":1,"highlight_end":53},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for _ in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        // Simulate synaptic input","highlight_start":1,"highlight_end":51},{"text":"                        let input = if neuron_id % 10 == 0 { 0.1 } else { 0.05 };","highlight_start":1,"highlight_end":82},{"text":"                        membrane_potential = membrane_potential * decay + input;","highlight_start":1,"highlight_end":81},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        if membrane_potential >= threshold {","highlight_start":1,"highlight_end":61},{"text":"                            membrane_potential = 0.0; // Reset","highlight_start":1,"highlight_end":63},{"text":"                            spikes_generated += 1;","highlight_start":1,"highlight_end":51},{"text":"                            counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":69},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    // spawn_task expects () return type","highlight_start":1,"highlight_end":57},{"text":"                    let _spikes = spikes_generated;","highlight_start":1,"highlight_end":52},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":14390,"byte_end":14400,"line_start":398,"line_end":398,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":14400,"byte_end":15412,"line_start":398,"line_end":419,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Simulate spike processing","highlight_start":1,"highlight_end":49},{"text":"                    let mut membrane_potential = 0.0f32;","highlight_start":1,"highlight_end":57},{"text":"                    let threshold = 1.0f32;","highlight_start":1,"highlight_end":44},{"text":"                    let decay = 0.95f32;","highlight_start":1,"highlight_end":41},{"text":"                    let mut spikes_generated = 0u64;","highlight_start":1,"highlight_end":53},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for _ in 0..operations_per_task {","highlight_start":1,"highlight_end":54},{"text":"                        // Simulate synaptic input","highlight_start":1,"highlight_end":51},{"text":"                        let input = if neuron_id % 10 == 0 { 0.1 } else { 0.05 };","highlight_start":1,"highlight_end":82},{"text":"                        membrane_potential = membrane_potential * decay + input;","highlight_start":1,"highlight_end":81},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        if membrane_potential >= threshold {","highlight_start":1,"highlight_end":61},{"text":"                            membrane_potential = 0.0; // Reset","highlight_start":1,"highlight_end":63},{"text":"                            spikes_generated += 1;","highlight_start":1,"highlight_end":51},{"text":"                            counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":69},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    // spawn_task expects () return type","highlight_start":1,"highlight_end":57},{"text":"                    let _spikes = spikes_generated;","highlight_start":1,"highlight_end":52},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    // Simulate spike processing\n                    let mut membrane_potential = 0.0f32;\n                    let threshold = 1.0f32;\n                    let decay = 0.95f32;\n                    let mut spikes_generated = 0u64;\n                    \n                    for _ in 0..operations_per_task {\n                        // Simulate synaptic input\n                        let input = if neuron_id % 10 == 0 { 0.1 } else { 0.05 };\n                        membrane_potential = membrane_potential * decay + input;\n                        \n                        if membrane_potential >= threshold {\n                            membrane_potential = 0.0; // Reset\n                            spikes_generated += 1;\n                            counter.fetch_add(1, Ordering::Relaxed);\n                        }\n                    }\n                    \n                    // spawn_task expects () return type\n                    let _spikes = spikes_generated;\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:398:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m398\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m399\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Simulate spike processing\n\u001b[1m\u001b[94m400\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut membrane_potential = 0.\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m401\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let threshold = 1.0f32;\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _spikes = spikes_generated;\n\u001b[1m\u001b[94m419\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m398\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _spikes = spikes_generated;\n\u001b[1m\u001b[94m419\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":16296,"byte_end":17619,"line_start":441,"line_end":468,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Simulate STDP (Spike-Timing Dependent Plasticity)","highlight_start":1,"highlight_end":73},{"text":"                    let mut weight = 0.5f32;","highlight_start":1,"highlight_end":45},{"text":"                    let learning_rate = 0.01f32;","highlight_start":1,"highlight_end":49},{"text":"                    let mut updates = 0u64;","highlight_start":1,"highlight_end":44},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for timestep in 0..operations_per_task {","highlight_start":1,"highlight_end":61},{"text":"                        // Simulate pre/post synaptic activity","highlight_start":1,"highlight_end":63},{"text":"                        let pre_spike = timestep % 20 == 0;","highlight_start":1,"highlight_end":60},{"text":"                        let post_spike = (timestep + 5) % 25 == 0;","highlight_start":1,"highlight_end":67},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        if pre_spike && post_spike {","highlight_start":1,"highlight_end":53},{"text":"                            // LTP (Long-Term Potentiation)","highlight_start":1,"highlight_end":60},{"text":"                            weight += learning_rate * (1.0 - weight);","highlight_start":1,"highlight_end":70},{"text":"                            updates += 1;","highlight_start":1,"highlight_end":42},{"text":"                        } else if pre_spike || post_spike {","highlight_start":1,"highlight_end":60},{"text":"                            // LTD (Long-Term Depression)","highlight_start":1,"highlight_end":58},{"text":"                            weight -= learning_rate * weight;","highlight_start":1,"highlight_end":62},{"text":"                            updates += 1;","highlight_start":1,"highlight_end":42},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        // Bounds checking","highlight_start":1,"highlight_end":43},{"text":"                        weight = weight.max(0.0).min(1.0);","highlight_start":1,"highlight_end":59},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    counter.fetch_add(updates, Ordering::Relaxed);","highlight_start":1,"highlight_end":67},{"text":"                    // Return () since spawn_task expects () return type","highlight_start":1,"highlight_end":73},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":16286,"byte_end":16296,"line_start":441,"line_end":441,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":16296,"byte_end":17619,"line_start":441,"line_end":468,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Simulate STDP (Spike-Timing Dependent Plasticity)","highlight_start":1,"highlight_end":73},{"text":"                    let mut weight = 0.5f32;","highlight_start":1,"highlight_end":45},{"text":"                    let learning_rate = 0.01f32;","highlight_start":1,"highlight_end":49},{"text":"                    let mut updates = 0u64;","highlight_start":1,"highlight_end":44},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for timestep in 0..operations_per_task {","highlight_start":1,"highlight_end":61},{"text":"                        // Simulate pre/post synaptic activity","highlight_start":1,"highlight_end":63},{"text":"                        let pre_spike = timestep % 20 == 0;","highlight_start":1,"highlight_end":60},{"text":"                        let post_spike = (timestep + 5) % 25 == 0;","highlight_start":1,"highlight_end":67},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        if pre_spike && post_spike {","highlight_start":1,"highlight_end":53},{"text":"                            // LTP (Long-Term Potentiation)","highlight_start":1,"highlight_end":60},{"text":"                            weight += learning_rate * (1.0 - weight);","highlight_start":1,"highlight_end":70},{"text":"                            updates += 1;","highlight_start":1,"highlight_end":42},{"text":"                        } else if pre_spike || post_spike {","highlight_start":1,"highlight_end":60},{"text":"                            // LTD (Long-Term Depression)","highlight_start":1,"highlight_end":58},{"text":"                            weight -= learning_rate * weight;","highlight_start":1,"highlight_end":62},{"text":"                            updates += 1;","highlight_start":1,"highlight_end":42},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        // Bounds checking","highlight_start":1,"highlight_end":43},{"text":"                        weight = weight.max(0.0).min(1.0);","highlight_start":1,"highlight_end":59},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    counter.fetch_add(updates, Ordering::Relaxed);","highlight_start":1,"highlight_end":67},{"text":"                    // Return () since spawn_task expects () return type","highlight_start":1,"highlight_end":73},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    // Simulate STDP (Spike-Timing Dependent Plasticity)\n                    let mut weight = 0.5f32;\n                    let learning_rate = 0.01f32;\n                    let mut updates = 0u64;\n                    \n                    for timestep in 0..operations_per_task {\n                        // Simulate pre/post synaptic activity\n                        let pre_spike = timestep % 20 == 0;\n                        let post_spike = (timestep + 5) % 25 == 0;\n                        \n                        if pre_spike && post_spike {\n                            // LTP (Long-Term Potentiation)\n                            weight += learning_rate * (1.0 - weight);\n                            updates += 1;\n                        } else if pre_spike || post_spike {\n                            // LTD (Long-Term Depression)\n                            weight -= learning_rate * weight;\n                            updates += 1;\n                        }\n                        \n                        // Bounds checking\n                        weight = weight.max(0.0).min(1.0);\n                    }\n                    \n                    counter.fetch_add(updates, Ordering::Relaxed);\n                    // Return () since spawn_task expects () return type\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:441:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m441\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m442\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Simulate STDP (Spike-Timing \u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m443\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut weight = 0.5f32;\n\u001b[1m\u001b[94m444\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let learning_rate = 0.01f32;\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m468\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m441\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m467\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Return () since spawn_task expects () return type\n\u001b[1m\u001b[94m468\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":21498,"byte_end":21664,"line_start":566,"line_end":570,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Minimal work","highlight_start":1,"highlight_end":36},{"text":"                    // spawn_task expects () return type","highlight_start":1,"highlight_end":57},{"text":"                    let _result = i * 2;","highlight_start":1,"highlight_end":41},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":21488,"byte_end":21498,"line_start":566,"line_end":566,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":21498,"byte_end":21664,"line_start":566,"line_end":570,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Minimal work","highlight_start":1,"highlight_end":36},{"text":"                    // spawn_task expects () return type","highlight_start":1,"highlight_end":57},{"text":"                    let _result = i * 2;","highlight_start":1,"highlight_end":41},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    // Minimal work\n                    // spawn_task expects () return type\n                    let _result = i * 2;\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:566:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m566\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m567\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Minimal work\n\u001b[1m\u001b[94m568\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // spawn_task expects () return\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m569\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _result = i * 2;\n\u001b[1m\u001b[94m570\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m566\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m569\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _result = i * 2;\n\u001b[1m\u001b[94m570\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":22561,"byte_end":22695,"line_start":592,"line_end":595,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Just a simple task for jitter measurement","highlight_start":1,"highlight_end":65},{"text":"                    let _dummy = 42;","highlight_start":1,"highlight_end":37},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":22551,"byte_end":22561,"line_start":592,"line_end":592,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":22561,"byte_end":22695,"line_start":592,"line_end":595,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    // Just a simple task for jitter measurement","highlight_start":1,"highlight_end":65},{"text":"                    let _dummy = 42;","highlight_start":1,"highlight_end":37},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    // Just a simple task for jitter measurement\n                    let _dummy = 42;\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:592:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m592\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m593\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Just a simple task for jitte\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m594\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _dummy = 42;\n\u001b[1m\u001b[94m595\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m592\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m593\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Just a simple task for jitter measurement\n\u001b[1m\u001b[94m594\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let _dummy = 42;\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `filled` found for struct `shnn_math::Vector` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":5861,"byte_end":5867,"line_start":171,"line_end":171,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"                let v = Vector::filled(self.config.data_size / 100, i as f32);","highlight_start":33,"highlight_end":39}],"label":"function or associated item not found in `shnn_math::Vector`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `shnn_math::Vector` consider using one of the following associated functions:\nshnn_math::Vector::zeros\nshnn_math::Vector::ones\nshnn_math::Vector::from_vec\nshnn_math::Vector::from_slice","code":null,"level":"note","spans":[{"file_name":"crates/shnn-math/src/vector.rs","byte_start":751,"byte_end":786,"line_start":28,"line_end":28,"column_start":5,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn zeros(length: usize) -> Self {","highlight_start":5,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":933,"byte_end":967,"line_start":35,"line_end":35,"column_start":5,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn ones(length: usize) -> Self {","highlight_start":5,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":1079,"byte_end":1120,"line_start":42,"line_end":42,"column_start":5,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn from_vec(data: Vec<Float>) -> Self {","highlight_start":5,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/vector.rs","byte_start":1193,"byte_end":1234,"line_start":47,"line_end":47,"column_start":5,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn from_slice(data: &[Float]) -> Self {","highlight_start":5,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `fill` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"crates/shnn-math/src/vector.rs","byte_start":6141,"byte_end":6177,"line_start":230,"line_end":230,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn fill(&mut self, value: Float) {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `filled` found for struct `shnn_math::Vector` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:171:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m171\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m let v = Vector::filled(self.config.data_size / 10\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `shnn_math::Vector`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `shnn_math::Vector` consider using one of the following associated functions:\n      shnn_math::Vector::zeros\n      shnn_math::Vector::ones\n      shnn_math::Vector::from_vec\n      shnn_math::Vector::from_slice\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/vector.rs:28:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn zeros(length: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ones(length: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_vec(data: Vec<Float>) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_slice(data: &[Float]) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `fill` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/vector.rs:230:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn fill(&mut self, value: Float) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `filled` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/memory.rs","byte_start":6426,"byte_end":6432,"line_start":185,"line_end":185,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"                let m = Matrix::filled(size, size, i as f32);","highlight_start":33,"highlight_end":39}],"label":"function or associated item not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Matrix` consider using one of the following associated functions:\nMatrix::zeros\nMatrix::ones\nMatrix::identity\nMatrix::from_vec\nMatrix::from_nested_vec","code":null,"level":"note","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":789,"byte_end":835,"line_start":30,"line_end":30,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn zeros(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1027,"byte_end":1072,"line_start":39,"line_end":39,"column_start":5,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn ones(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1227,"byte_end":1263,"line_start":48,"line_end":48,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn identity(size: usize) -> Self {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1474,"byte_end":1549,"line_start":57,"line_end":57,"column_start":5,"column_end":80,"is_primary":true,"text":[{"text":"    pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {","highlight_start":5,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1837,"byte_end":1898,"line_start":68,"line_end":68,"column_start":5,"column_end":66,"is_primary":true,"text":[{"text":"    pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {","highlight_start":5,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `fill` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":7605,"byte_end":7641,"line_start":271,"line_end":271,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn fill(&mut self, value: Float) {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `filled` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/memory.rs:185:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m let m = Matrix::filled(size, size, i as f32);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Matrix`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Matrix` consider using one of the following associated functions:\n      Matrix::zeros\n      Matrix::ones\n      Matrix::identity\n      Matrix::from_vec\n      Matrix::from_nested_vec\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:30:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn zeros(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ones(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn identity(size: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `fill` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:271:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m271\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn fill(&mut self, value: Float) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `filled` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":14877,"byte_end":14883,"line_start":429,"line_end":429,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"            let mut weights = Matrix::filled(self.config.neuron_count, self.config.neuron_count, 0.1);","highlight_start":39,"highlight_end":45}],"label":"function or associated item not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Matrix` consider using one of the following associated functions:\nMatrix::zeros\nMatrix::ones\nMatrix::identity\nMatrix::from_vec\nMatrix::from_nested_vec","code":null,"level":"note","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":789,"byte_end":835,"line_start":30,"line_end":30,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn zeros(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1027,"byte_end":1072,"line_start":39,"line_end":39,"column_start":5,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn ones(rows: usize, cols: usize) -> Self {","highlight_start":5,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1227,"byte_end":1263,"line_start":48,"line_end":48,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn identity(size: usize) -> Self {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1474,"byte_end":1549,"line_start":57,"line_end":57,"column_start":5,"column_end":80,"is_primary":true,"text":[{"text":"    pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {","highlight_start":5,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":1837,"byte_end":1898,"line_start":68,"line_end":68,"column_start":5,"column_end":66,"is_primary":true,"text":[{"text":"    pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {","highlight_start":5,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `fill` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"crates/shnn-math/src/matrix.rs","byte_start":7605,"byte_end":7641,"line_start":271,"line_end":271,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn fill(&mut self, value: Float) {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `filled` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:429:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m429\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0meights = Matrix::filled(self.config.neuron_count, \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Matrix`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Matrix` consider using one of the following associated functions:\n      Matrix::zeros\n      Matrix::ones\n      Matrix::identity\n      Matrix::from_vec\n      Matrix::from_nested_vec\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:30:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn zeros(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ones(rows: usize, cols: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn identity(size: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_vec(data: Vec<Float>, rows: usize, cols: usize) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_nested_vec(data: Vec<Vec<Float>>) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `fill` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-math/src/matrix.rs:271:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m271\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn fill(&mut self, value: Float) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":15778,"byte_end":15804,"line_start":445,"line_end":445,"column_start":50,"column_end":76,"is_primary":true,"text":[{"text":"                                let new_weight = (current_weight + delta_w).min(1.0).max(0.0);","highlight_start":50,"highlight_end":76}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:445:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m445\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m = (current_weight + delta_w).min(1.0).max(0.0);\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `get_row` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":17058,"byte_end":17065,"line_start":477,"line_end":477,"column_start":34,"column_end":41,"is_primary":true,"text":[{"text":"                        q_values.get_row(next_state),","highlight_start":34,"highlight_end":41}],"label":"method not found in `Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `get_row` found for struct `Matrix` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:477:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m477\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         q_values.get_row(next_state),\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `Matrix`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":17144,"byte_end":17152,"line_start":479,"line_end":479,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"                        let max_next_q = next_row.iter().fold(0.0f32, |acc, &x| acc.max(x));","highlight_start":42,"highlight_end":50}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:479:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m479\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   let max_next_q = next_row.iter().fold(0.0f32, |\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":17183,"byte_end":17186,"line_start":479,"line_end":479,"column_start":81,"column_end":84,"is_primary":false,"text":[{"text":"                        let max_next_q = next_row.iter().fold(0.0f32, |acc, &x| acc.max(x));","highlight_start":81,"highlight_end":84}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":17174,"byte_end":17177,"line_start":479,"line_end":479,"column_start":72,"column_end":75,"is_primary":true,"text":[{"text":"                        let max_next_q = next_row.iter().fold(0.0f32, |acc, &x| acc.max(x));","highlight_start":72,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":17177,"byte_end":17177,"line_start":479,"line_end":479,"column_start":75,"column_end":75,"is_primary":true,"text":[{"text":"                        let max_next_q = next_row.iter().fold(0.0f32, |acc, &x| acc.max(x));","highlight_start":75,"highlight_end":75}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:479:72\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m479\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m.fold(0.0f32, |acc, &x| acc.max(x));\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m      \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m479\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                        let max_next_q = next_row.iter().fold(0.0f32, |acc\u001b[92m: /* Type */\u001b[0m, &x| acc.max(x));\n    \u001b[1m\u001b[94m|\u001b[0m                                                                           \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":18456,"byte_end":19227,"line_start":514,"line_end":530,"column_start":48,"column_end":19,"is_primary":false,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    let mut processed = 0u64;","highlight_start":1,"highlight_end":46},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for _timestep in 0..config.time_steps / 4 {","highlight_start":1,"highlight_end":64},{"text":"                        // Simulate spike processing","highlight_start":1,"highlight_end":53},{"text":"                        for _neuron in 0..config.neuron_count / 4 {","highlight_start":1,"highlight_end":68},{"text":"                            if rand::random::<f32>() < config.spike_probability {","highlight_start":1,"highlight_end":82},{"text":"                                // Process spike","highlight_start":1,"highlight_end":49},{"text":"                                let _membrane_update = 0.1f32 * exp_approx(-0.1);","highlight_start":1,"highlight_end":82},{"text":"                                processed += 1;","highlight_start":1,"highlight_end":48},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    counter.fetch_add(processed, Ordering::Relaxed);","highlight_start":1,"highlight_end":69},{"text":"                    // Task must return () for spawn_task","highlight_start":1,"highlight_end":58},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":"argument #2 of type `TaskPriority` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":18446,"byte_end":18456,"line_start":514,"line_end":514,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/shnn-async-runtime/src/lib.rs","byte_start":6044,"byte_end":6054,"line_start":209,"line_end":209,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"    pub fn spawn_task<F>(&self, future: F, priority: TaskPriority) -> TaskHandle<()>","highlight_start":12,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":18456,"byte_end":19227,"line_start":514,"line_end":530,"column_start":48,"column_end":19,"is_primary":true,"text":[{"text":"                let handle = runtime.spawn_task(async move {","highlight_start":48,"highlight_end":61},{"text":"                    let mut processed = 0u64;","highlight_start":1,"highlight_end":46},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    for _timestep in 0..config.time_steps / 4 {","highlight_start":1,"highlight_end":64},{"text":"                        // Simulate spike processing","highlight_start":1,"highlight_end":53},{"text":"                        for _neuron in 0..config.neuron_count / 4 {","highlight_start":1,"highlight_end":68},{"text":"                            if rand::random::<f32>() < config.spike_probability {","highlight_start":1,"highlight_end":82},{"text":"                                // Process spike","highlight_start":1,"highlight_end":49},{"text":"                                let _membrane_update = 0.1f32 * exp_approx(-0.1);","highlight_start":1,"highlight_end":82},{"text":"                                processed += 1;","highlight_start":1,"highlight_end":48},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    ","highlight_start":1,"highlight_end":21},{"text":"                    counter.fetch_add(processed, Ordering::Relaxed);","highlight_start":1,"highlight_end":69},{"text":"                    // Task must return () for spawn_task","highlight_start":1,"highlight_end":58},{"text":"                });","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"(async move {\n                    let mut processed = 0u64;\n                    \n                    for _timestep in 0..config.time_steps / 4 {\n                        // Simulate spike processing\n                        for _neuron in 0..config.neuron_count / 4 {\n                            if rand::random::<f32>() < config.spike_probability {\n                                // Process spike\n                                let _membrane_update = 0.1f32 * exp_approx(-0.1);\n                                processed += 1;\n                            }\n                        }\n                    }\n                    \n                    counter.fetch_add(processed, Ordering::Relaxed);\n                    // Task must return () for spawn_task\n                }, /* TaskPriority */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:514:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m514\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let handle = runtime.spawn_task(asy\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m515\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut processed = 0u64;\n\u001b[1m\u001b[94m516\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \n\u001b[1m\u001b[94m517\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for _timestep in 0..config.time\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m530\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 });\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94margument #2 of type `TaskPriority` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-async-runtime/src/lib.rs:209:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn spawn_task<F>(&self, future: F, priority: \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m514\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let handle = runtime.spawn_task(async move {\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m529\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     // Task must return () for spawn_task\n\u001b[1m\u001b[94m530\u001b[0m \u001b[92m~ \u001b[0m                }\u001b[92m, /* TaskPriority */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `sum` is assigned to, but never used","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":3139,"byte_end":3146,"line_start":101,"line_end":101,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    let mut sum = 0u64;","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using `_sum` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable `sum` is assigned to, but never used\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:101:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m101\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut sum = 0u64;\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `_sum` instead\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `sum` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":3217,"byte_end":3225,"line_start":103,"line_end":103,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"                        sum += j;","highlight_start":25,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: value assigned to `sum` is never read\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:103:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         sum += j;\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: maybe it is overwritten before being read?\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":2990,"byte_end":2991,"line_start":98,"line_end":98,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            for i in 0..self.config.task_count {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":2990,"byte_end":2991,"line_start":98,"line_end":98,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"            for i in 0..self.config.task_count {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:98:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for i in 0..self.config.task_count {\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `executor`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":7430,"byte_end":7438,"line_start":215,"line_end":215,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            let executor = Executor::new_work_stealing(self.config.worker_threads);","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":7430,"byte_end":7438,"line_start":215,"line_end":215,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            let executor = Executor::new_work_stealing(self.config.worker_threads);","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":"_executor","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `executor`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:215:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let executor = Executor::new_work_stealin\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_executor`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `executor`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":6415,"byte_end":6423,"line_start":189,"line_end":189,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            let executor = Executor::new_work_stealing(self.config.worker_threads);","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":6415,"byte_end":6423,"line_start":189,"line_end":189,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            let executor = Executor::new_work_stealing(self.config.worker_threads);","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":"_executor","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `executor`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:189:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let executor = Executor::new_work_stealin\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_executor`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `processed`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":10098,"byte_end":10107,"line_start":282,"line_end":282,"column_start":27,"column_end":36,"is_primary":true,"text":[{"text":"                if let Ok(processed) = handle.join() {","highlight_start":27,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":10098,"byte_end":10107,"line_start":282,"line_end":282,"column_start":27,"column_end":36,"is_primary":true,"text":[{"text":"                if let Ok(processed) = handle.join() {","highlight_start":27,"highlight_end":36}],"label":null,"suggested_replacement":"_processed","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `processed`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:282:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if let Ok(processed) = handle.join() {\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_processed`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12391,"byte_end":12402,"line_start":350,"line_end":350,"column_start":17,"column_end":28,"is_primary":true,"text":[{"text":"            let mut handles: Vec<std::thread::JoinHandle<u64>> = Vec::new();","highlight_start":17,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12391,"byte_end":12395,"line_start":350,"line_end":350,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"            let mut handles: Vec<std::thread::JoinHandle<u64>> = Vec::new();","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:350:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m350\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   let mut handles: Vec<std::thread::JoinHandle<u6\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"variable `sum` is assigned to, but never used","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12912,"byte_end":12919,"line_start":361,"line_end":361,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    let mut sum = 0u64;","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using `_sum` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable `sum` is assigned to, but never used\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:361:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let mut sum = 0u64;\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `_sum` instead\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `sum` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":13006,"byte_end":13027,"line_start":363,"line_end":363,"column_start":25,"column_end":46,"is_primary":true,"text":[{"text":"                        sum += (i + j) as u64;","highlight_start":25,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: value assigned to `sum` is never read\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:363:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m363\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         sum += (i + j) as u64;\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: maybe it is overwritten before being read?\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `handles`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12391,"byte_end":12402,"line_start":350,"line_end":350,"column_start":17,"column_end":28,"is_primary":true,"text":[{"text":"            let mut handles: Vec<std::thread::JoinHandle<u64>> = Vec::new();","highlight_start":17,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12391,"byte_end":12402,"line_start":350,"line_end":350,"column_start":17,"column_end":28,"is_primary":true,"text":[{"text":"            let mut handles: Vec<std::thread::JoinHandle<u64>> = Vec::new();","highlight_start":17,"highlight_end":28}],"label":null,"suggested_replacement":"_handles","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `handles`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:350:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m350\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let mut handles: Vec<std::thread::JoinHan\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_handles`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `priority`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12641,"byte_end":12649,"line_start":354,"line_end":354,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"                let priority = match i % 3 {","highlight_start":21,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":12641,"byte_end":12649,"line_start":354,"line_end":354,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"                let priority = match i % 3 {","highlight_start":21,"highlight_end":29}],"label":null,"suggested_replacement":"_priority","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `priority`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:354:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m354\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let priority = match i % 3 {\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_priority`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `executed` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/async_runtime.rs","byte_start":13313,"byte_end":13317,"line_start":372,"line_end":372,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"            let mut executed = 0u64;","highlight_start":32,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: value assigned to `executed` is never read\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/async_runtime.rs:372:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m372\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let mut executed = 0u64;\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[33m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: maybe it is overwritten before being read?\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `timestep`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":12650,"byte_end":12658,"line_start":370,"line_end":370,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            for timestep in 0..self.config.time_steps {","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/shnn-bench/src/neuromorphic.rs","byte_start":12650,"byte_end":12658,"line_start":370,"line_end":370,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"            for timestep in 0..self.config.time_steps {","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":"_timestep","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `timestep`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/shnn-bench/src/neuromorphic.rs:370:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for timestep in 0..self.config.time_steps {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_timestep`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 19 previous errors; 23 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 19 previous errors; 23 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0282, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0282, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
